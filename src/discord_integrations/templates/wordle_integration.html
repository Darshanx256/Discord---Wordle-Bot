<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Discord Wordle Integration</title>
<link href="https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&family=Unbounded:wght@400;700;900&display=swap" rel="stylesheet">
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

:root {
  --bg:           #f9f9f6;
  --surface:      #ffffff;
  --border:       #d3d6da;
  --border-filled:#878a8c;
  --text:         #1a1a1b;
  --muted:        #878a8c;
  --correct:      #6aaa64;
  --correct-dark: #538d4e;
  --present:      #c9b458;
  --present-dark: #b59f3b;
  --absent:       #787c7e;
  --key-bg:       #d3d6da;
  --key-text:     #1a1a1b;
  --tile-size:    52px;
  --tile-gap:     5px;
  --tile-font:    22px;
  --key-h:        46px;
  --key-font:     12px;
  --kb-gap:       5px;
  --app-safe-top: 0px;
  --side-col-left: 70px;
  --side-col-right: 70px;
  --name-max: 38px;
}

html, body {
  height: 100%;
  height: 100dvh;
  background: var(--bg);
  color: var(--text);
  font-family: 'Space Mono', monospace;
  overflow: hidden;
  -webkit-tap-highlight-color: transparent;
  user-select: none;
}

#app {
  display: flex;
  flex-direction: column;
  height: calc(100dvh - var(--app-safe-top));
  width: 100%;
  max-width: 500px;
  margin: 0 auto;
  margin-top: var(--app-safe-top);
}

header {
  flex-shrink: 0;
  background: var(--surface);
  border-bottom: 1px solid var(--border);
  padding: 0 14px;
  height: 52px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 8px;
}

body.activity-mobile {
  --app-safe-top: calc(env(safe-area-inset-top, 0px) + 46px);
}
body.activity-mobile header {
  border-bottom-left-radius: 14px;
  border-bottom-right-radius: 14px;
  box-shadow: 0 4px 14px rgba(26, 26, 27, 0.08);
}

body.pip-mode #keyboard,
body.pip-mode #disclaimer,
body.pip-mode #toast-container {
  display: none;
}
body.pip-mode #app {
  max-width: none;
}
body.pip-mode header {
  height: 36px;
  padding: 0 8px;
}
body.pip-mode .header-stats {
  display: none;
}
body.pip-mode .logo {
  font-size: 13px;
  letter-spacing: 0.1em;
}
body.pip-mode .logo-icon {
  width: 16px;
  height: 16px;
}
body.pip-square #grid-wrap {
  padding: 6px;
}
body.pip-square .row-user,
body.pip-square .row-spacer {
  display: none;
}
body.pip-square .tile {
  background: #f3f4f6;
}

.logo-wrap {
  display: flex;
  align-items: center;
  gap: 8px;
}

.logo-icon {
  width: 20px;
  height: 20px;
  object-fit: contain;
  flex-shrink: 0;
}

.logo {
  font-family: 'Unbounded', sans-serif;
  font-weight: 900;
  font-size: 17px;
  letter-spacing: 0.16em;
  color: var(--text);
  flex-shrink: 0;
}

.header-stats {
  display: flex;
  align-items: center;
  gap: 6px;
  flex-shrink: 0;
}

.stat-chip {
  display: flex;
  align-items: center;
  gap: 5px;
  background: #f0f0ed;
  border: 1px solid var(--border);
  border-radius: 20px;
  padding: 4px 10px 4px 8px;
  font-size: 10px;
  font-weight: 700;
  color: var(--text);
  white-space: nowrap;
}

.stat-chip svg { width: 13px; height: 13px; flex-shrink: 0; }
.stat-chip .chip-label { color: var(--muted); }
.stat-chip .chip-val { font-family: 'Unbounded', sans-serif; font-size: 11px; font-weight: 900; }
.chip-wr .chip-val { color: var(--correct-dark); }
.chip-players .chip-val { color: #2563eb; }

#toast-container {
  position: fixed;
  top: calc(58px + var(--app-safe-top));
  left: 50%;
  transform: translateX(-50%);
  z-index: 200;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 6px;
  pointer-events: none;
}

.toast {
  background: #1a1a1b;
  color: #fff;
  font-family: 'Unbounded', sans-serif;
  font-size: 11px;
  font-weight: 700;
  letter-spacing: 0.07em;
  padding: 8px 16px;
  border-radius: 4px;
  white-space: nowrap;
  animation: toastIn 0.18s cubic-bezier(0.34,1.56,0.64,1) forwards;
}
.toast.out { animation: toastOut 0.22s ease forwards; }
@keyframes toastIn { from { opacity:0; transform:translateY(-8px) scale(0.9); } to { opacity:1; transform:translateY(0) scale(1); } }
@keyframes toastOut { from { opacity:1; } to { opacity:0; transform:translateY(-6px); } }

#grid-wrap {
  flex: 1;
  min-height: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 6px 8px;
  overflow: hidden;
}

#grid {
  display: flex;
  flex-direction: column;
  gap: var(--tile-gap);
}

.row-wrap {
  display: flex;
  align-items: center;
  gap: 8px;
}

.row-user {
  width: var(--side-col-left);
  flex-shrink: 0;
  display: flex;
  align-items: center;
  justify-content: flex-end;
  gap: 5px;
  opacity: 0;
  transform: translateX(4px);
  transition: opacity 0.28s ease, transform 0.28s ease;
}
.row-user.visible { opacity: 1; transform: translateX(0); }

.user-avatar {
  width: 24px;
  height: 24px;
  border-radius: 50%;
  background: var(--correct);
  display: flex;
  align-items: center;
  justify-content: center;
  font-family: 'Unbounded', sans-serif;
  font-size: 8px;
  font-weight: 900;
  color: #fff;
  flex-shrink: 0;
  box-shadow: 0 1px 4px rgba(0,0,0,0.18);
  border: 2px solid #fff;
  background-size: cover;
  background-position: center;
}

.user-name {
  font-size: 10px;
  font-weight: 700;
  color: var(--muted);
  letter-spacing: 0.03em;
  max-width: var(--name-max);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  text-align: right;
  line-height: 1;
}

.row-spacer { width: var(--side-col-right); flex-shrink: 0; }
.tile-row { display: flex; gap: var(--tile-gap); }

.tile {
  width:  var(--tile-size);
  height: var(--tile-size);
  border: 2px solid var(--border);
  border-radius: 4px;
  background: #fff;
  display: flex;
  align-items: center;
  justify-content: center;
  font-family: 'Unbounded', sans-serif;
  font-weight: 700;
  font-size: var(--tile-font);
  color: var(--text);
  transform-style: preserve-3d;
  perspective: 600px;
  will-change: transform;
}

.tile.filled { border-color: var(--border-filled); animation: pop 0.1s cubic-bezier(0.34,1.56,0.64,1); }
.tile.shake { animation: shake 0.45s ease; }
.tile.reveal { animation: flip3d var(--flip-dur, 460ms) ease forwards; animation-delay: var(--flip-delay, 0s); }
.tile.bounce { animation: bounce 0.55s cubic-bezier(0.34,1.56,0.64,1) forwards; animation-delay: var(--bounce-delay, 0s); }
.tile.carry-in { animation: carryDown 0.24s cubic-bezier(0.22, 1, 0.36, 1) both; animation-delay: var(--carry-delay, 0s); }

@keyframes flip3d {
  0% { transform: rotateX(0deg); }
  49% { transform: rotateX(-90deg); }
  50% { transform: rotateX(-90deg); background: var(--tile-bg); border-color: var(--tile-bg); color: #fff; }
  100% { transform: rotateX(0deg); background: var(--tile-bg); border-color: var(--tile-bg); color: #fff; }
}
@keyframes pop { 50% { transform: scale(1.1); } }
@keyframes shake {
  15% { transform: translateX(-5px) rotate(-0.8deg); }
  30% { transform: translateX(5px)  rotate(0.8deg); }
  50% { transform: translateX(-4px); }
  70% { transform: translateX(4px); }
  90% { transform: translateX(-2px); }
}
@keyframes bounce {
  25% { transform: translateY(-11px) scale(1.07); }
  50% { transform: translateY(0) scale(0.97); }
  75% { transform: translateY(-4px) scale(1.02); }
  100% { transform: translateY(0) scale(1); }
}
@keyframes carryDown {
  from { transform: translateY(calc(-1 * (var(--tile-size) + var(--tile-gap)))) scale(0.98); opacity: 0.35; }
  to { transform: translateY(0) scale(1); opacity: 1; }
}

#keyboard {
  flex-shrink: 0;
  width: 100%;
  padding: 4px 6px 6px;
  display: flex;
  flex-direction: column;
  gap: var(--kb-gap);
}

.kb-row { display: flex; justify-content: center; gap: var(--kb-gap); }

.key {
  height: var(--key-h);
  flex: 1;
  min-width: 0;
  max-width: 43px;
  border: none;
  border-radius: 4px;
  background: var(--key-bg);
  color: var(--key-text);
  font-family: 'Space Mono', monospace;
  font-size: var(--key-font);
  font-weight: 700;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;
  overflow: hidden;
  touch-action: manipulation;
  transition: background 0.18s, color 0.18s, transform 0.07s;
  -webkit-tap-highlight-color: transparent;
}
.key.wide { max-width: 64px; font-size: calc(var(--key-font) - 1px); }
.key:active { transform: scale(0.91); }
.key::after { content: ''; position: absolute; inset: 0; background: rgba(0,0,0,0.06); opacity: 0; transition: opacity 0.1s; }
.key:hover::after { opacity: 1; }
.key .ripple {
  position: absolute;
  border-radius: 50%;
  background: rgba(0,0,0,0.09);
  transform: scale(0);
  animation: ripple 0.38s ease-out;
  pointer-events: none;
}
@keyframes ripple { to { transform: scale(3.5); opacity: 0; } }
.key.state-correct { background: var(--correct); color: #fff; }
.key.state-present { background: var(--present); color: #fff; }
.key.state-absent  { background: var(--absent); color: #fff; }
.key.state-update  { animation: keyPop 0.3s ease; }
.key.submitting-enter { background: var(--correct-dark); color: #fff; animation: keyPending 0.65s ease-in-out infinite; }
@keyframes keyPop { 40% { transform: scale(1.13); } 100% { transform: scale(1); } }
@keyframes keyPending { 0%,100% { filter: brightness(1); } 50% { filter: brightness(1.15); } }

#win-overlay {
  display: none;
  position: fixed;
  inset: 0;
  z-index: 150;
  align-items: center;
  justify-content: center;
  background: rgba(249,249,246,0.86);
  backdrop-filter: blur(6px);
}
#win-overlay.show { display: flex; }

.win-card {
  background: #fff;
  border: 2px solid var(--border);
  border-radius: 14px;
  padding: 20px 22px;
  text-align: center;
  width: 90%;
  max-width: 320px;
  box-shadow: 0 10px 40px rgba(0,0,0,0.1);
  animation: cardIn 0.36s cubic-bezier(0.34,1.56,0.64,1);
}
@keyframes cardIn { from { opacity:0; transform: scale(0.82) translateY(14px); } to { opacity:1; transform: scale(1) translateY(0); } }

.winner-avatar {
  width: 54px;
  height: 54px;
  border-radius: 50%;
  margin: 0 auto 8px;
  border: 2px solid #fff;
  background: var(--correct);
  background-size: cover;
  background-position: center;
  box-shadow: 0 1px 4px rgba(0,0,0,0.18);
}
.win-title { font-family: 'Unbounded', sans-serif; font-size: 19px; font-weight: 900; color: var(--text); margin-bottom: 5px; }
.lose-title { color: #c0392b; }
.win-sub { font-size: 11px; color: var(--muted); letter-spacing: 0.04em; margin-bottom: 4px; }
.win-word { font-family: 'Unbounded', sans-serif; font-size: 24px; font-weight: 700; color: var(--correct-dark); letter-spacing: 0.13em; margin: 10px 0 14px; }
#breakdown {
  max-height: 120px;
  overflow-y: auto;
  text-align: left;
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 8px;
  margin-bottom: 12px;
  font-size: 11px;
}
.break-row {
  display: flex;
  justify-content: space-between;
  gap: 6px;
  margin-bottom: 4px;
}
.break-row:last-child { margin-bottom: 0; }

.btn {
  width: 100%;
  background: var(--correct);
  border: none;
  border-radius: 6px;
  color: #fff;
  font-family: 'Unbounded', sans-serif;
  font-size: 11px;
  font-weight: 700;
  letter-spacing: 0.1em;
  padding: 11px 0;
  cursor: pointer;
  transition: background 0.18s, transform 0.08s;
}
.btn:hover { background: var(--correct-dark); }
.btn:active { transform: scale(0.97); }
.btn[disabled] { opacity: 0.55; cursor: not-allowed; }

#confetti-canvas { position: fixed; inset: 0; z-index: 149; pointer-events: none; }
.particle {
  position: fixed;
  width: 7px;
  height: 7px;
  border-radius: 2px;
  pointer-events: none;
  z-index: 148;
  animation: particleFly var(--dur) ease-out forwards;
}
@keyframes particleFly {
  0% { transform: translate(0,0) scale(1) rotate(0deg); opacity:1; }
  100% { transform: translate(var(--tx),var(--ty)) scale(0) rotate(200deg); opacity:0; }
}

#loading-mask {
  display: none;
  position: fixed;
  inset: 0;
  z-index: 201;
  align-items: center;
  justify-content: center;
  background: rgba(249,249,246,0.92);
}
#loading-mask.show { display: flex; }
.loading-card {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 10px;
  font-family: 'Unbounded', sans-serif;
  font-size: 12px;
  letter-spacing: 0.08em;
  background: #fff;
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 12px 14px;
}
.loading-label {
  color: var(--text);
}
.loading-jump {
  display: flex;
  gap: 5px;
}
.loading-jump .dot {
  width: 13px;
  height: 13px;
  border-radius: 3px;
  background: var(--correct);
  animation: loadingJump 0.9s ease-in-out infinite;
}
.loading-jump .dot:nth-child(2) { animation-delay: 0.08s; }
.loading-jump .dot:nth-child(3) { animation-delay: 0.16s; }
.loading-jump .dot:nth-child(4) { animation-delay: 0.24s; }
.loading-jump .dot:nth-child(5) { animation-delay: 0.32s; }
@keyframes loadingJump {
  0%, 100% { transform: translateY(0); opacity: 0.58; }
  40% { transform: translateY(-8px); opacity: 1; }
  60% { transform: translateY(-4px); opacity: 0.9; }
}

#disclaimer {
  text-align: center;
  color: var(--muted);
  font-size: 10px;
  padding-bottom: 8px;
}
</style>
</head>
<body>
<div id="app">
  <header>
    <div class="logo-wrap">
      <img class="logo-icon" id="logo-icon" src="/integration/static/icon.png?v=20260224b" alt="Logo">
      <div class="logo" id="mode-title">CLASSIC</div>
    </div>
    <div class="header-stats">
      <div class="stat-chip chip-wr">
        <svg viewBox="0 0 24 24" fill="none" stroke="#538d4e" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M6 9H4a2 2 0 0 1-2-2V5h4"></path><path d="M18 9h2a2 2 0 0 0 2-2V5h-4"></path>
          <path d="M12 17v4"></path><path d="M8 21h8"></path>
          <path d="M6 5h12v7a6 6 0 0 1-12 0V5z"></path>
        </svg>
        <span class="chip-label">WR</span>
        <span class="chip-val" id="wr-val">â€”</span>
      </div>
      <div class="stat-chip chip-players">
        <svg viewBox="0 0 24 24" fill="none" stroke="#2563eb" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
          <circle cx="9" cy="7" r="4"></circle>
          <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
          <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
        </svg>
        <span class="chip-val" id="players-val">â€”</span>
        <span class="chip-label">participants</span>
      </div>
    </div>
  </header>

  <div id="grid-wrap"><div id="grid"></div></div>
  <div id="keyboard"></div>
  <div id="disclaimer">Not affiliated with The New York Times.</div>
</div>

<div id="toast-container"></div>
<canvas id="confetti-canvas"></canvas>
<div id="loading-mask">
  <div class="loading-card">
    <div class="loading-label">SYNCING WITH DISCORD</div>
    <div class="loading-jump" aria-hidden="true">
      <span class="dot"></span>
      <span class="dot"></span>
      <span class="dot"></span>
      <span class="dot"></span>
      <span class="dot"></span>
    </div>
  </div>
</div>

<div id="win-overlay">
  <div class="win-card">
    <div class="winner-avatar" id="winner-avatar"></div>
    <div class="win-title" id="win-title">BRILLIANT!</div>
    <div class="win-sub" id="win-sub">Solved in <strong id="win-attempts">?</strong> attempts</div>
    <div class="win-word" id="win-word"></div>
    <div id="breakdown"></div>
    <button class="btn" id="retry-btn">PLAY AGAIN</button>
  </div>
</div>

<script>
const INITIAL_TOKEN = {{ token|tojson }};
const ACTIVITY_MODE = {{ activity_mode|tojson }};
const ACTIVITY_CLIENT_ID = {{ activity_client_id|tojson }};
const SESSION_KEY = "wordle_integration_session_token";

function computeIntegrationBase() {
  const p = window.location.pathname || "";
  const marker = "/integration/";
  const i = p.indexOf(marker);
  if (i >= 0) return p.slice(0, i) + "/integration";
  if (p.endsWith("/integration")) return p;
  return "";
}

const INTEGRATION_BASE = computeIntegrationBase();
const API_BASE = new URL("./../api", window.location.origin + (window.location.pathname.endsWith("/") ? window.location.pathname : window.location.pathname + "/")).pathname.replace(/\/$/, "");
const STATIC_BASE = new URL("./../static", window.location.origin + (window.location.pathname.endsWith("/") ? window.location.pathname : window.location.pathname + "/")).pathname.replace(/\/$/, "");
const API_BASE_CANDIDATES = Array.from(new Set([
  API_BASE,
  INTEGRATION_BASE ? `${INTEGRATION_BASE}/activity/api` : "/integration/activity/api",
  "/integration/api",
  "/activity/api",
  "/api"
]));
const URL_PARAMS = new URLSearchParams(window.location.search);
const IS_PHONE = /iphone|ipod|android|mobile/i.test(navigator.userAgent || "") || String(URL_PARAMS.get("platform") || "").toLowerCase() === "mobile";

const ROWS = 6;
const COLS = 5;
const FLIP_DUR = 460;
const FLIP_STAGGER = 90;
const COLORS = ['#6aaa64','#c9b458','#538d4e','#b59f3b','#4a90d9','#e67e22','#e74c3c'];
const KB_ROWS = [
  ['Q','W','E','R','T','Y','U','I','O','P'],
  ['A','S','D','F','G','H','J','K','L'],
  ['ENTER','Z','X','C','V','B','N','M','âŒ«']
];

let sessionToken = INITIAL_TOKEN || sessionStorage.getItem(SESSION_KEY) || "";
let state = null;
let localInput = [];
let keyMap = {};
let submitting = false;
let preferredApiBase = null;
let carryInputPending = false;
let revealUserLockRow = -1;
let noActiveNoticeShown = false;
const ICON_VERSION = "20260224b";
let rowRefs = [];
let enterBtn = null;
let pollInFlight = false;
let layoutModeValue = -1; // Discord SDK layout mode: 0 focused, 1 pip, 2 grid

const gridEl = document.getElementById('grid');
const kbEl = document.getElementById('keyboard');
document.getElementById("logo-icon").src = `${STATIC_BASE}/icon.png?v=${ICON_VERSION}`;

function setLoading(on) {
  document.getElementById('loading-mask').classList.toggle('show', Boolean(on));
}

if (ACTIVITY_MODE && IS_PHONE) {
  document.body.classList.add('activity-mobile');
}

function applyMobileTopInset() {
  if (!ACTIVITY_MODE || !IS_PHONE) return;
  const dynTop = Math.max(46, Math.round(window.innerHeight * 0.062));
  document.documentElement.style.setProperty('--app-safe-top', `calc(env(safe-area-inset-top, 0px) + ${dynTop}px)`);
}

function applySurfaceMode() {
  const vw = window.innerWidth;
  const vh = window.innerHeight;
  const aspect = vh > 0 ? (vw / vh) : 1;
  const sdkPip = Number(layoutModeValue) === 1;
  const viewportLikelyPip = ACTIVITY_MODE && vw <= 640 && vh <= 420;
  const pip = sdkPip || viewportLikelyPip;
  const square = pip && aspect <= 1.15;
  document.body.classList.toggle('pip-mode', pip);
  document.body.classList.toggle('pip-square', square);
  document.body.classList.toggle('pip-wide', pip && !square);
}

function showToast(msg, ms = 1400) {
  const c = document.getElementById('toast-container');
  const t = document.createElement('div');
  t.className = 'toast';
  t.textContent = msg;
  c.appendChild(t);
  setTimeout(() => {
    t.classList.add('out');
    setTimeout(() => t.remove(), 260);
  }, ms);
}

function clearBoardAndKeyboard() {
  for (let r = 0; r < ROWS; r++) {
    const rowRef = rowRefs[r];
    if (!rowRef) continue;
    const userDiv = rowRef.userDiv;
    const nameEl = rowRef.nameEl;
    const avatarEl = rowRef.avatarEl;
    if (userDiv) userDiv.classList.remove('visible');
    if (nameEl) nameEl.textContent = '';
    if (avatarEl) {
      avatarEl.style.backgroundImage = '';
      avatarEl.textContent = '';
    }
    for (let c = 0; c < COLS; c++) {
      const t = tileAt(r, c);
      if (!t) continue;
      t.className = 'tile';
      t.textContent = '';
      t.style.background = '';
      t.style.borderColor = '';
      t.style.color = '';
      t.style.removeProperty('--tile-bg');
      t.style.removeProperty('--flip-dur');
      t.style.removeProperty('--flip-delay');
      t.style.removeProperty('--bounce-delay');
      t.style.removeProperty('--carry-delay');
    }
  }
  Object.keys(keyMap).forEach(k => {
    const btn = keyMap[k];
    btn.className = 'key';
  });
  kbEl.querySelectorAll('.key.wide').forEach(k => k.classList.add('wide'));
  document.getElementById('win-overlay').classList.remove('show');
}

async function fetchJsonWithFallback(path, options = {}) {
  const errs = [];
  const orderedBases = preferredApiBase
    ? [preferredApiBase, ...API_BASE_CANDIDATES.filter(base => base !== preferredApiBase)]
    : API_BASE_CANDIDATES;
  for (const base of orderedBases) {
    const url = `${base}${path}`;
    try {
      const res = await fetch(url, options);
      const raw = await res.text();
      let data = null;
      try {
        data = JSON.parse(raw);
      } catch {
        errs.push(`${url} -> non-json: ${raw.slice(0, 60)}`);
        continue;
      }
      preferredApiBase = base;
      return { data, url, status: res.status };
    } catch (e) {
      errs.push(`${url} -> fetch error: ${String(e)}`);
    }
  }
  throw new Error(`All API bases failed for ${path}: ${errs.join(" | ")}`);
}

function calcLayout() {
  const vw = window.innerWidth;
  const vh = window.innerHeight;
  applySurfaceMode();
  const pipMode = document.body.classList.contains('pip-mode');
  const pipSquare = document.body.classList.contains('pip-square');
  const sideColLeft = pipSquare ? 0 : (IS_PHONE ? 92 : 70);
  const sideColRight = pipSquare ? 0 : (IS_PHONE ? 38 : 70);
  const nameMax = pipSquare ? 0 : (IS_PHONE ? 66 : 38);
  const headerH = pipMode ? 36 : 52;
  const kbRows = 3;
  const kbGap = Math.min(6, Math.max(4, vh * 0.007));
  const kbKeyH = Math.min(IS_PHONE ? 56 : 52, Math.max(IS_PHONE ? 40 : 36, vh * (IS_PHONE ? 0.072 : 0.067)));
  const kbPad = 12;
  const kbH = pipMode ? 0 : (kbKeyH * kbRows + kbGap * (kbRows - 1) + kbPad);
  const gridPad = 10;
  const gridH = vh - headerH - kbH - gridPad * 2;
  const sideW = sideColLeft + sideColRight + 8 * 2;
  const gridW = Math.min(vw, 500) - sideW - 16;
  const tileGap = Math.min(6, Math.max(3, vw * 0.012));
  const fromH = (gridH - tileGap * (ROWS - 1)) / ROWS;
  const fromW = (gridW - tileGap * (COLS - 1)) / COLS;
  const maxTile = pipSquare ? Math.min(64, Math.max(28, Math.floor(vw * 0.16))) : (IS_PHONE ? 70 : 64);
  const tSize = Math.floor(Math.min(fromH, fromW, maxTile));

  const root = document.documentElement;
  root.style.setProperty('--side-col-left', sideColLeft + 'px');
  root.style.setProperty('--side-col-right', sideColRight + 'px');
  root.style.setProperty('--name-max', nameMax + 'px');
  root.style.setProperty('--tile-size', tSize + 'px');
  root.style.setProperty('--tile-gap', tileGap + 'px');
  root.style.setProperty('--tile-font', Math.round(tSize * 0.41) + 'px');
  root.style.setProperty('--key-h', Math.round(kbKeyH) + 'px');
  root.style.setProperty('--key-font', Math.max(9, Math.round(kbKeyH * 0.26)) + 'px');
  root.style.setProperty('--kb-gap', kbGap + 'px');
  applyMobileTopInset();
}

function initialsFrom(name) {
  const n = String(name || 'P').trim();
  return n.slice(0, 2).toUpperCase();
}

function breakdownMarkup(items) {
  if (!Array.isArray(items) || !items.length) return '<div class="break-row"><span>No breakdown</span><span>â€”</span></div>';
  return items.map(item => {
    const status = item.solved ? 'Solved' : `${item.best_greens}/5 greens`;
    return `<div class="break-row"><span>#${item.rank} ${escapeHtml(item.name)}</span><span>${status}</span></div>`;
  }).join('');
}

function escapeHtml(value) {
  return String(value || '').replace(/[&<>"']/g, ch => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[ch]));
}

function tileAt(r, c) {
  const row = rowRefs[r];
  if (!row) return null;
  return row.tiles[c] || null;
}

function buildGrid() {
  gridEl.innerHTML = '';
  rowRefs = [];
  for (let r = 0; r < ROWS; r++) {
    const wrap = document.createElement('div');
    wrap.className = 'row-wrap';

    const userDiv = document.createElement('div');
    userDiv.className = 'row-user';
    const nameEl = document.createElement('div');
    nameEl.className = 'user-name';
    const avatarEl = document.createElement('div');
    avatarEl.className = 'user-avatar';
    userDiv.append(nameEl, avatarEl);
    wrap.appendChild(userDiv);

    const tileRow = document.createElement('div');
    tileRow.className = 'tile-row';
    const tiles = [];
    for (let c = 0; c < COLS; c++) {
      const t = document.createElement('div');
      t.className = 'tile';
      tileRow.appendChild(t);
      tiles.push(t);
    }
    wrap.appendChild(tileRow);

    const spacer = document.createElement('div');
    spacer.className = 'row-spacer';
    wrap.appendChild(spacer);
    gridEl.appendChild(wrap);
    rowRefs.push({ wrap, userDiv, nameEl, avatarEl, tiles });
  }
}

function refreshFromState() {
  if (!state) return;
  document.getElementById('mode-title').textContent = String(state.mode_label || 'Classic').toUpperCase();
  document.getElementById('wr-val').textContent = state.wr ?? 'â€”';
  document.getElementById('players-val').textContent = state.participants ?? 'â€”';

  const keyPriority = { correct: 3, present: 2, absent: 1 };
  const keyState = {};

  for (let r = 0; r < ROWS; r++) {
    const rowRef = rowRefs[r];
    if (!rowRef) continue;
    const userDiv = rowRef.userDiv;
    const nameEl = rowRef.nameEl;
    const avatarEl = rowRef.avatarEl;

    const rowData = state.rows && state.rows[r] ? state.rows[r] : null;
    const word = rowData ? String(rowData.word || '').toUpperCase() : '';
    const states = rowData ? (rowData.states || []) : [];

    if (rowData && rowData.user) {
      if (r === revealUserLockRow) userDiv.classList.remove('visible');
      else userDiv.classList.add('visible');
      nameEl.textContent = rowData.user.name || 'Player';
      if (rowData.user.avatar_url) {
        avatarEl.style.backgroundImage = `url('${rowData.user.avatar_url}')`;
        avatarEl.textContent = '';
      } else {
        avatarEl.style.backgroundImage = '';
        avatarEl.textContent = initialsFrom(rowData.user.name);
      }
    } else {
      userDiv.classList.remove('visible');
      nameEl.textContent = '';
      avatarEl.style.backgroundImage = '';
      avatarEl.textContent = '';
    }

    for (let c = 0; c < COLS; c++) {
      const t = tileAt(r, c);
      const ch = word[c] || '';
      t.className = 'tile';

      if (rowData) {
        t.textContent = ch;
        if (ch) t.classList.add('filled');
        const st = states[c] || '';
        if (st) {
          if (st === 'correct' || st === 'present' || st === 'absent') {
            t.style.setProperty('--tile-bg', st === 'correct' ? '#6aaa64' : st === 'present' ? '#c9b458' : '#787c7e');
            t.style.background = t.style.getPropertyValue('--tile-bg');
            t.style.borderColor = t.style.getPropertyValue('--tile-bg');
            t.style.color = '#fff';
          }
          const old = keyState[ch] || '';
          if (ch && (keyPriority[st] || 0) > (keyPriority[old] || 0)) keyState[ch] = st;
        }
      } else if (!state.game_over && r === state.attempts_used && c < localInput.length) {
        t.textContent = localInput[c];
        t.classList.add('filled');
        if (carryInputPending) {
          t.style.setProperty('--carry-delay', `${c * 35}ms`);
          t.classList.add('carry-in');
        }
      } else {
        t.textContent = '';
      }
    }
  }

  Object.keys(keyMap).forEach(k => {
    const btn = keyMap[k];
    const ks = keyState[k] || '';
    btn.className = 'key';
    if (ks) btn.classList.add('state-' + ks);
  });
  kbEl.querySelectorAll('.key.wide').forEach(k => k.classList.add('wide'));
  if (enterBtn && submitting) enterBtn.classList.add('submitting-enter');

  const overlay = document.getElementById('win-overlay');
  if (state.game_over) {
    overlay.classList.add('show');
    const winTitle = document.getElementById('win-title');
    const winSub = document.getElementById('win-sub');
    const winWord = document.getElementById('win-word');
    const winAttempts = document.getElementById('win-attempts');
    const winnerAvatar = document.getElementById('winner-avatar');
    const retryBtn = document.getElementById('retry-btn');
    const breakdown = document.getElementById('breakdown');

    if (state.winner) {
      winTitle.className = 'win-title';
      winTitle.textContent = `${state.winner.name} WON!`;
      winSub.innerHTML = `Solved in <strong id="win-attempts">${state.attempts_used}</strong> attempts`;
      winWord.textContent = state.secret || '';
      if (state.winner.avatar_url) winnerAvatar.style.backgroundImage = `url('${state.winner.avatar_url}')`;
      if (state.winner.avatar_url) winnerAvatar.textContent = '';
      else winnerAvatar.textContent = initialsFrom(state.winner.name);
    } else {
      winTitle.className = 'win-title lose-title';
      winTitle.textContent = 'GAME OVER';
      winSub.textContent = 'The word was:';
      winWord.textContent = state.secret || '';
      winnerAvatar.style.backgroundImage = '';
      winnerAvatar.textContent = 'ðŸ’€';
    }
    if (winAttempts) winAttempts.textContent = String(state.attempts_used || '?');
    breakdown.innerHTML = breakdownMarkup(state.breakdown);
    retryBtn.disabled = !state.can_retry;
  } else {
    overlay.classList.remove('show');
  }
  carryInputPending = false;
}

function buildKeyboard() {
  kbEl.innerHTML = '';
  keyMap = {};
  enterBtn = null;
  KB_ROWS.forEach(rowKeys => {
    const row = document.createElement('div');
    row.className = 'kb-row';
    rowKeys.forEach(k => {
      const btn = document.createElement('button');
      btn.className = 'key' + (k.length > 1 ? ' wide' : '');
      btn.textContent = k;
      btn.addEventListener('pointerdown', e => {
        e.preventDefault();
        addRipple(btn, e);
        handleKey(k);
      });
      row.appendChild(btn);
      if (k === 'ENTER') enterBtn = btn;
      if (k.length === 1) keyMap[k] = btn;
    });
    kbEl.appendChild(row);
  });
}

function addRipple(btn, e) {
  const r = document.createElement('span');
  r.className = 'ripple';
  const rect = btn.getBoundingClientRect();
  const sz = Math.max(rect.width, rect.height);
  r.style.cssText = `width:${sz}px;height:${sz}px;left:${(e.clientX ?? rect.left+rect.width/2)-rect.left-sz/2}px;top:${(e.clientY ?? rect.top+rect.height/2)-rect.top-sz/2}px`;
  btn.appendChild(r);
  setTimeout(() => r.remove(), 420);
}

function shakeRow(row) {
  for (let c = 0; c < COLS; c++) {
    const t = tileAt(row, c);
    if (!t) continue;
    t.classList.remove('shake');
    void t.offsetWidth;
    t.classList.add('shake');
  }
}

function bounceRow(row) {
  for (let c = 0; c < COLS; c++) {
    const t = tileAt(row, c);
    if (!t) continue;
    t.style.setProperty('--bounce-delay', `${c * 75}ms`);
    t.classList.remove('bounce');
    void t.offsetWidth;
    t.classList.add('bounce');
  }
}

async function revealRow(rowIndex, letters, states) {
  const BG = { correct: '#6aaa64', present: '#c9b458', absent: '#787c7e' };
  revealUserLockRow = rowIndex;
  const rowRef = rowRefs[rowIndex];
  if (rowRef && rowRef.userDiv) rowRef.userDiv.classList.remove('visible');
  for (let c = 0; c < COLS; c++) {
    const tile = tileAt(rowIndex, c);
    if (!tile) continue;
    tile.textContent = letters[c] || '';
    tile.classList.add('filled');
    tile.style.setProperty('--tile-bg', BG[states[c]] || '#787c7e');
    tile.style.setProperty('--flip-dur', FLIP_DUR + 'ms');
    tile.style.setProperty('--flip-delay', (c * FLIP_STAGGER) + 'ms');
    tile.classList.add('reveal');
  }
  await new Promise(res => setTimeout(res, COLS * FLIP_STAGGER + FLIP_DUR + 40));
  revealUserLockRow = -1;
}

function spawnParticles() {
  for (let i = 0; i < 30; i++) {
    const p = document.createElement('div');
    p.className = 'particle';
    const ang = Math.random() * 360;
    const d = 70 + Math.random() * 160;
    const dur = 0.55 + Math.random() * 0.4;
    p.style.cssText = `left:${36+Math.random()*28}%;top:${28+Math.random()*18}%;background:${COLORS[Math.floor(Math.random()*COLORS.length)]};--tx:${Math.cos(ang*Math.PI/180)*d}px;--ty:${Math.sin(ang*Math.PI/180)*d-70}px;--dur:${dur}s`;
    document.body.appendChild(p);
    setTimeout(() => p.remove(), dur * 1000 + 80);
  }
}

function launchConfetti() {
  const cv = document.getElementById('confetti-canvas');
  const ctx = cv.getContext('2d');
  cv.width = window.innerWidth;
  cv.height = window.innerHeight;
  const pp = Array.from({ length: 90 }, () => ({
    x: Math.random()*cv.width, y: -10-Math.random()*80,
    vx: (Math.random()-.5)*3.5, vy: 2+Math.random()*3.5,
    rot: Math.random()*360, vrot: (Math.random()-.5)*7,
    color: COLORS[Math.floor(Math.random()*COLORS.length)],
    w: 6+Math.random()*7, h: 4+Math.random()*5
  }));
  (function draw() {
    ctx.clearRect(0, 0, cv.width, cv.height);
    let alive = false;
    pp.forEach(p => {
      p.x+=p.vx; p.y+=p.vy; p.vy+=.07; p.rot+=p.vrot;
      if (p.y < cv.height+20) alive = true;
      ctx.save();
      ctx.globalAlpha = Math.min(1, Math.max(0, 1-p.y/cv.height)*3);
      ctx.translate(p.x, p.y);
      ctx.rotate(p.rot*Math.PI/180);
      ctx.fillStyle = p.color;
      ctx.fillRect(-p.w/2,-p.h/2,p.w,p.h);
      ctx.restore();
    });
    if (alive) requestAnimationFrame(draw);
    else ctx.clearRect(0,0,cv.width,cv.height);
  })();
}

async function fetchState(showMask = false) {
  if (!sessionToken) {
    showToast('Session not ready');
    return false;
  }
  if (showMask) setLoading(true);
  try {
    const { data, url } = await fetchJsonWithFallback(`/state?token=${encodeURIComponent(sessionToken)}`);
    if (!data.ok) {
      const errLower = String(data.error || "").toLowerCase();
      if (errLower.includes("no active channel game")) {
        localInput = [];
        carryInputPending = false;
        state = null;
        clearBoardAndKeyboard();
        if (!noActiveNoticeShown) showToast('Waiting for a game in this channel', 1200);
        noActiveNoticeShown = true;
        return false;
      }
      showToast(`${data.error || 'Failed to load'} (${url})`);
      if ((data.error || "").toLowerCase().includes("token")) {
        sessionStorage.removeItem(SESSION_KEY);
      }
      return false;
    }
    if (noActiveNoticeShown) {
      showToast('New game started', 900);
      noActiveNoticeShown = false;
    }
    const prevState = state;
    if (!submitting && prevState && !prevState.game_over && localInput.length > 0) {
      const prevAttempts = Number(prevState.attempts_used || 0);
      const nextAttempts = Number((data.state && data.state.attempts_used) || 0);
      if (nextAttempts > prevAttempts) {
        if (nextAttempts >= ROWS) localInput = [];
        else carryInputPending = true;
      }
    }
    state = data.state;
    if (state && state.game_over) localInput = [];
    refreshFromState();
    return true;
  } finally {
    if (showMask) setLoading(false);
  }
}

async function submitGuess() {
  if (submitting || !state || state.game_over) return;
  if (localInput.length < COLS) {
    shakeRow(state.attempts_used);
    showToast('Not enough letters');
    return;
  }

  submitting = true;
  let submittedOk = false;
  const rowIndex = state.attempts_used;
  const guess = localInput.join('');
  refreshFromState();

  try {
    const { data, url } = await fetchJsonWithFallback(`/guess`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ token: sessionToken, word: guess })
    });
    if (!data.ok) {
      const beforeAttempts = rowIndex;
      const loaded = await fetchState(false);
      if (!loaded && !state) return;
      const afterAttempts = Number((state && state.attempts_used) || beforeAttempts);
      const nowOver = Boolean(state && state.game_over);
      const advanced = loaded && afterAttempts > beforeAttempts;
      if (advanced || nowOver) {
        if (afterAttempts >= ROWS || nowOver) localInput = [];
        else carryInputPending = true;
        return;
      }
      shakeRow(rowIndex);
      showToast(`${data.error || 'Guess rejected'} (${url})`);
      return;
    }

    const acceptedIndex = Number.isInteger(data.guess_row_index) ? data.guess_row_index : rowIndex;
    const rowData = data.state.rows && data.state.rows[acceptedIndex] ? data.state.rows[acceptedIndex] : null;
    if (rowData) {
      await revealRow(acceptedIndex, String(rowData.word || guess).toUpperCase().split(''), rowData.states || []);
    }

    if (rowData && (rowData.states || []).every(s => s === 'correct')) {
      bounceRow(acceptedIndex);
      spawnParticles();
      launchConfetti();
    }

    localInput = [];
    carryInputPending = false;
    state = data.state;
    submittedOk = true;
    refreshFromState();
  } finally {
    submitting = false;
    if (!submittedOk) refreshFromState();
  }
}

function handleKey(key) {
  if (!state || state.game_over || submitting) return;
  if (key === 'âŒ«' || key === 'BACKSPACE') {
    if (localInput.length > 0) localInput.pop();
    refreshFromState();
    return;
  }
  if (key === 'ENTER') {
    submitGuess();
    return;
  }
  if (/^[A-Z]$/.test(key) && localInput.length < COLS) {
    localInput.push(key);
    refreshFromState();
  }
}

async function retryGame() {
  if (submitting || !state || !state.game_over) return;
  submitting = true;
  setLoading(true);
  try {
    const { data, url } = await fetchJsonWithFallback(`/retry`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ token: sessionToken })
    });
    if (!data.ok) {
      showToast(`${data.error || 'Retry failed'} (${url})`);
      return;
    }
    if (data.token) {
      sessionToken = String(data.token || "");
      if (sessionToken) sessionStorage.setItem(SESSION_KEY, sessionToken);
    }
    localInput = [];
    carryInputPending = false;
    state = data.state;
    document.getElementById('confetti-canvas').getContext('2d').clearRect(0, 0, window.innerWidth, window.innerHeight);
    refreshFromState();
  } finally {
    setLoading(false);
    submitting = false;
  }
}

function detectChannelIdFromUrl() {
  const params = new URLSearchParams(window.location.search);
  const direct = params.get('channel_id') || params.get('channelId') || params.get('cid');
  if (direct) return String(direct);

  const location = params.get('location_id') || '';
  if (!location) return '';

  // Accept raw snowflake or extract first snowflake-like token from compound values.
  if (/^\d{16,22}$/.test(location)) return location;
  const m = String(location).match(/\d{16,22}/);
  return m ? m[0] : '';
}

async function bootstrapActivitySession() {
  if (!ACTIVITY_MODE) return Boolean(sessionToken);
  if (sessionToken) return true;
  if (!ACTIVITY_CLIENT_ID) {
    showToast('Missing activity client id');
    return false;
  }

  setLoading(true);
  try {
    const sdkModule = await import('https://esm.sh/@discord/embedded-app-sdk');
    const DiscordSDK = sdkModule.DiscordSDK || (sdkModule.default && sdkModule.default.DiscordSDK) || sdkModule.default;
    if (!DiscordSDK) throw new Error('Discord SDK unavailable');

    const discordSdk = new DiscordSDK(ACTIVITY_CLIENT_ID);
    await discordSdk.ready();
    try {
      await discordSdk.subscribe('ACTIVITY_LAYOUT_MODE_UPDATE', (payload) => {
        const nextMode = Number(payload && payload.layout_mode);
        if (!Number.isNaN(nextMode)) {
          layoutModeValue = nextMode;
          calcLayout();
          refreshFromState();
        }
      });
    } catch (_) {
      // Some clients may not emit/allow this event; viewport heuristic remains as fallback.
    }

    let channelId = String(discordSdk.channelId || '') || detectChannelIdFromUrl();
    if (!channelId) {
      try {
        const ch = await discordSdk.commands.getChannel({});
        channelId = String(ch?.id || ch?.channel_id || '');
      } catch (_) {}
    }

    const activityPath = INTEGRATION_BASE ? `${INTEGRATION_BASE}/activity` : "/activity";
    const redirectUri = `${window.location.origin}${activityPath}`;
    const authRes = await discordSdk.commands.authorize({
      client_id: ACTIVITY_CLIENT_ID,
      response_type: 'code',
      state: 'wordle-activity',
      prompt: 'none',
      scope: ['identify']
    });

    const { data: oauthData, url: oauthUrl } = await fetchJsonWithFallback(`/activity/oauth-token`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ code: authRes.code, redirect_uri: redirectUri })
    });
    if (!oauthData.ok) throw new Error(`${oauthData.error || 'OAuth exchange failed'} (${oauthUrl})`);

    await discordSdk.commands.authenticate({ access_token: oauthData.access_token });

    const { data: sessData, url: sessUrl } = await fetchJsonWithFallback(`/activity/session-token`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        access_token: oauthData.access_token,
        channel_id: channelId || null,
        location_id: new URLSearchParams(window.location.search).get('location_id') || null,
        scope: 'channel'
      })
    });
    if (!sessData.ok) throw new Error(`${sessData.error || 'Session token failed'} (${sessUrl})`);
    sessionToken = sessData.token;
    sessionStorage.setItem(SESSION_KEY, sessionToken);
    return true;
  } catch (err) {
    sessionStorage.removeItem(SESSION_KEY);
    showToast(String(err && err.message ? err.message : err));
    return false;
  } finally {
    setLoading(false);
  }
}

document.addEventListener('keydown', e => {
  if (e.ctrlKey || e.metaKey || e.altKey) return;
  const k = e.key.toUpperCase();
  if (k === 'BACKSPACE') handleKey('âŒ«');
  else if (k === 'ENTER') handleKey('ENTER');
  else if (/^[A-Z]$/.test(k)) handleKey(k);
});

document.getElementById('retry-btn').addEventListener('click', retryGame);
window.addEventListener('resize', calcLayout);
document.addEventListener('visibilitychange', () => {
  if (!document.hidden && sessionToken && !submitting && !pollInFlight) {
    pollInFlight = true;
    fetchState(false).finally(() => { pollInFlight = false; });
  }
});

buildGrid();
buildKeyboard();
calcLayout();

(async () => {
  const ok = await bootstrapActivitySession();
  if (!ok) return;
  const loaded = await fetchState(true);
  if (!loaded) return;
  setInterval(() => {
    if (submitting || pollInFlight) return;
    pollInFlight = true;
    fetchState(false).finally(() => { pollInFlight = false; });
  }, 1400);
})();
</script>
</body>
</html>
